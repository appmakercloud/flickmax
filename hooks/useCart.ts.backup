/**
 * useCart Hook - Shopping Cart State Management
 * 
 * This custom React hook manages the shopping cart state and provides
 * methods for cart operations. It integrates with the client-side cart
 * service and handles localStorage persistence.
 * 
 * KEY FEATURES:
 * - Automatic cart initialization with unique cart ID
 * - Cart persistence across page refreshes
 * - Real-time cart item count
 * - Toast notifications for user feedback
 * - Error handling with user-friendly messages
 * 
 * USAGE:
 * ```tsx
 * const { cart, addDomainToCart, removeFromCart, cartItemsCount } = useCart()
 * ```
 * 
 * IMPORTANT NOTES:
 * - Cart ID is stored in localStorage and persists across sessions
 * - All cart operations are handled client-side
 * - Price updates happen in CartPanel component when country changes
 * 
 * @returns Object with cart state and methods
 */
import { useState, useCallback, useEffect } from 'react'
import { Cart, AddToCartRequest, CartItem } from '@/types/cart'
import { clientCartService } from '@/lib/api/client-cart'
import toast from 'react-hot-toast'

// Create a global event emitter for cart animations
export const cartAnimationEvent = typeof window !== 'undefined' ? new EventTarget() : null

export function useCart() {
  const [cart, setCart] = useState<Cart | null>(null)
  const [cartId, setCartId] = useState<string | null>(null)
  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  
  // Trigger animation through custom event
  const triggerCartAnimation = useCallback(() => {
    if (cartAnimationEvent) {
      cartAnimationEvent.dispatchEvent(new CustomEvent('cartAnimation'))
    }
  }, [])

  const generateCartId = () => {
    return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15)
  }

  const fetchCart = useCallback(async (id: string) => {
    if (!id) return
    
    try {
      setIsLoading(true)
      const cartData = await clientCartService.getCart(id)
      setCart(cartData)
      setError(null)
    } catch (error) {
      // Silently handle cart fetch errors - it's normal for cart to not exist initially
      setError(null)
      setCart(null)
    } finally {
      setIsLoading(false)
    }
  }, [])

  // Initialize cart ID from localStorage
  useEffect(() => {
    const storedCartId = localStorage.getItem('cartId')
    if (storedCartId) {
      setCartId(storedCartId)
      fetchCart(storedCartId)
    } else {
      // Generate new cart ID
      const newCartId = generateCartId()
      localStorage.setItem('cartId', newCartId)
      setCartId(newCartId)
    }
  }, [fetchCart])

  /**
   * Add multiple items to cart
   * 
   * This is the base method for adding items. It handles:
   * - Adding new items or updating quantities for existing ones
   * - Fetching current prices from the domain API
   * - Showing success notifications
   * 
   * @param items - Array of items to add to cart
   * @returns Object with updated cart or undefined on error
   */
  const addToCart = useCallback(async (items: CartItem[]) => {
    if (!cartId) {
      return
    }
    

    try {
      setIsLoading(true)
      setError(null)

      // Use client-side cart service
      const updatedCart = await clientCartService.addToCart(cartId, items)
      setCart(updatedCart)
      
      // Force a refresh to ensure state is synced
      const refreshedCart = await clientCartService.getCart(cartId)
      setCart(refreshedCart)
      
      // Trigger cart animation instead of toast
      triggerCartAnimation()
      
      return { cart: refreshedCart }
    } catch (error) {
      const message = error instanceof Error ? error.message : 'Failed to add to cart'
      setError(message)
      toast.error(message)
    } finally {
      setIsLoading(false)
    }
  }, [cartId])

  /**
   * Add a domain to cart
   * 
   * Convenience method for adding domain registrations to cart.
   * Automatically fetches current pricing based on user's selected currency.
   * 
   * @param domain - The domain name (e.g., 'example.com')
   * @param productId - The product ID for the domain TLD
   * @returns Object with updated cart or undefined on error
   */
  const addDomainToCart = useCallback(async (domain: string, productId: string | number) => {
    const item: CartItem = {
      id: String(productId),
      domain,
      quantity: 1,
      pfid: typeof productId === 'number' ? productId : parseInt(productId) || undefined
    }
    
    return addToCart([item])
  }, [addToCart])

  const addProductToCart = useCallback(async (productId: string, period?: number, periodUnit?: string) => {
    const item: CartItem = {
      id: productId,
      pfid: parseInt(productId) || undefined,
      quantity: 1,
      period,
      periodUnit
    }
    
    return addToCart([item])
  }, [addToCart])

  const clearCart = useCallback(async () => {
    if (!cartId) return

    try {
      setIsLoading(true)
      // Use client-side cart service
      await clientCartService.clearCart(cartId)
      const emptyCart = await clientCartService.getCart(cartId)
      setCart(emptyCart)
      toast.success('Cart cleared successfully!')
    } catch (error) {
      const message = error instanceof Error ? error.message : 'Failed to clear cart'
      setError(message)
      toast.error(message)
    } finally {
      setIsLoading(false)
    }
  }, [cartId])

  const cartItemsCount = cart?.items?.reduce((total, item) => total + (item.quantity || 1), 0) || 0

  const removeFromCart = useCallback(async (itemId: string) => {
    if (!cartId || !cart) return

    try {
      setIsLoading(true)
      setError(null)

      // Remove item from local cart
      const updatedItems = cart.items.filter(item => item.id !== itemId)
      const updatedCart = {
        ...cart,
        items: updatedItems,
        subtotal: updatedItems.reduce((sum, item) => sum + item.subtotal, 0),
        total: updatedItems.reduce((sum, item) => sum + item.subtotal, 0) // No tax
      }
      
      setCart(updatedCart)
      await clientCartService.saveLocalCart(updatedCart)
      
      toast.success('Item removed from cart')
    } catch (error) {
      const message = error instanceof Error ? error.message : 'Failed to remove item'
      setError(message)
      toast.error(message)
    } finally {
      setIsLoading(false)
    }
  }, [cart, cartId])

  const updateQuantity = useCallback(async (itemId: string, newQuantity: number) => {
    if (!cartId || !cart) return

    try {
      setIsLoading(true)
      setError(null)

      // Update quantity in local cart
      const updatedItems = cart.items.map(item => {
        if (item.id === itemId) {
          return {
            ...item,
            quantity: newQuantity,
            subtotal: item.price * newQuantity
          }
        }
        return item
      })

      const updatedCart = {
        ...cart,
        items: updatedItems,
        subtotal: updatedItems.reduce((sum, item) => sum + item.subtotal, 0),
        total: updatedItems.reduce((sum, item) => sum + item.subtotal, 0) // No tax
      }
      
      setCart(updatedCart)
      await clientCartService.saveLocalCart(updatedCart)
      
      toast.success('Quantity updated')
    } catch (error) {
      const message = error instanceof Error ? error.message : 'Failed to update quantity'
      setError(message)
      toast.error(message)
    } finally {
      setIsLoading(false)
    }
  }, [cart, cartId])

  const refreshCart = useCallback(() => {
    if (cartId) {
      fetchCart(cartId)
    }
  }, [cartId, fetchCart])

  return {
    cart,
    cartId,
    isLoading,
    error,
    addToCart,
    addDomainToCart,
    addProductToCart,
    clearCart,
    getCartItemsCount: () => cartItemsCount,
    cartItemsCount,
    removeFromCart,
    updateQuantity,
    refreshCart
  }
}